---
sidebar: sidebar 
permalink: trident-get-started/kubernetes-customize-deploy.html 
keywords: deploy, trident, methods, operator, tridentctl, helm, attributes, customize, tridentorchestrator, smb, windows 
summary: 'Mit dem Operator Trident können Sie die Art und Weise, wie Trident installiert wird, mithilfe der Attribute in der Spezifikation anpassen `TridentOrchestrator`.' 
---
= Anpassen der Trident Operator-Installation
:hardbreaks:
:allow-uri-read: 
:icons: font
:imagesdir: ../media/


[role="lead"]
Mit dem Operator Trident können Sie die Trident-Installation mithilfe der Attribute in der Spezifikation anpassen `TridentOrchestrator`. Wenn Sie die Installation über die Argumente hinaus anpassen möchten `TridentOrchestrator`, sollten Sie die Verwendung verwenden, `tridentctl` um benutzerdefinierte YAML-Manifeste zu erstellen, die bei Bedarf geändert werden.



== Allgemeines zu Controller-Pods und Node-Pods

Trident läuft als einzelner Controller-Pod und als Node-Pod auf jedem Worker-Knoten im Cluster. Der Node-Pod muss auf jedem Host ausgeführt werden, auf dem Sie möglicherweise ein Trident -Volume einbinden möchten.

Kubernetes link:https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/["Knotenauswahl"^] Und link:https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/["Toleranzen und Verfleckungen"^] Werden verwendet, um die Ausführung eines Pod auf einem bestimmten oder bevorzugten Node einzuschränken. Verwenden von`ControllerPlugin` und `NodePlugin`, Sie können Bedingungen und Überschreibungen festlegen.

* Das Controller-Plug-in übernimmt Volume-Bereitstellung und -Management, beispielsweise Snapshots und Größenanpassungen.
* Das Node-Plug-in verarbeitet das Verbinden des Speichers mit dem Node.




== Konfigurationsoptionen


WARNING: `spec.namespace` Wird in angegeben `TridentOrchestrator`, um den Namespace zu kennzeichnen, in dem Trident installiert ist. Dieser Parameter *kann nicht aktualisiert werden, nachdem Trident installiert wurde*. Der Versuch, dies zu tun, führt dazu, dass der `TridentOrchestrator` Status in geändert `Failed` wird. Trident soll nicht über Namespaces hinweg migriert werden.

Diese Tabelle enthält Einzelheiten `TridentOrchestrator` Attribute.

[cols="1,2,1"]
|===
| Parameter | Beschreibung | Standard 


| `namespace` | Namespace, in dem Trident installiert werden soll | `"default"` 


| `debug` | Debugging für Trident aktivieren | `false` 


| `enableForceDetach` | `ontap-san`, `ontap-san-economy` , `ontap-nas` , Und `ontap-nas-economy` nur. Funktioniert mit Kubernetes Non-Graceful Node Shutdown (NGNS), um Cluster-Administratoren die Möglichkeit zu geben, Workloads mit eingebundenen Volumes sicher auf neue Knoten zu migrieren, falls ein Knoten in einen instabilen Zustand gerät. Weitere Informationen finden Sie unterlink:../trident-reco/force-detach.html["Automatisierung des Failovers zustandsbehafteter Anwendungen mit Trident"] . | `false` 


| `windows` | Einstellung auf `true` Ermöglicht die Installation auf Windows Worker-Knoten. | `false` 


| `cloudProvider`  a| 
Einstellung auf `"Azure"` bei Verwendung von verwalteten Identitäten oder einer Cloud-Identität auf einem AKS-Cluster. Legen Sie bei Verwendung einer Cloud-Identität auf einem EKS-Cluster fest `"AWS"`. Einstellung auf `"GCP"` bei Verwendung einer Cloud-Identität auf einem GKE-Cluster.
| `""` 


| `cloudIdentity`  a| 
Bei Verwendung der Cloud-Identität auf einem AKS-Cluster auf Workload-Identität („Azure.Workload.Identity/Client-id: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxx“) einstellen. Bei Verwendung der Cloud-Identität auf einem EKS-Cluster auf AWS iam-Rolle (“'eks.amazonaws.com/role-arn: arn:aws:iam::123456:role/Trident-role') einstellen. Bei Verwendung der Cloud-Identität auf einem GKE-Cluster auf Cloud-Identität ("iam.gke.io/gcp-Service-Account: xxxx@mygcpproject.iam.gserviceaccount.com'") gesetzt.
| `""` 


| `IPv6` | Installieren Sie Trident über IPv6 | Falsch 


| `k8sTimeout`  a| 
Zeitüberschreitung für Kubernetes-Operationen.


NOTE: Der `k8sTimeout` Der Parameter ist nur für die Trident -Installation anwendbar.
| `180sec` 


| `silenceAutosupport` | Senden Sie keine AutoSupport Bundles an NetApp
Automatisch | `false` 


| `autosupportImage` | Das Container-Image für AutoSupport Telemetrie | `"netapp/trident-autosupport10"` 


| `autosupportProxy` | Die Adresse/den Port eines Proxys zum Senden von AutoSupport
Telemetrie | `"http://proxy.example.com:8888"` 


| `uninstall` | Ein Flag, mit dem Trident deinstalliert wird | `false` 


| `logFormat` | Verwendetes Trident-Protokollierungsformat [Text,json] | `"text"` 


| `tridentImage` | Zu installierendes Trident-Image | `"netapp/trident:25.10"` 


| `imageRegistry` | Pfad zur internen Registrierung des Formats
`<registry FQDN>[:port][/subpath]` | `"registry.k8s.io"` 


| `kubeletDir` | Pfad zum kubelet-Verzeichnis auf dem Host | `"/var/lib/kubelet"` 


| `wipeout` | Eine Liste der zu löschenden Ressourcen, um Trident vollständig zu entfernen |  


| `imagePullSecrets` | Secrets, um Bilder aus einer internen Registrierung zu ziehen |  


| `imagePullPolicy` | Legt die BildPull-Richtlinie für den Trident-Operator fest. Gültige Werte sind:
`Always` Um immer das Bild zu ziehen.
`IfNotPresent` Nur wenn das Image nicht auf dem Node vorhanden ist, soll das Image kopiert werden.
`Never` Nie das Bild ziehen. | `IfNotPresent` 


| `controllerPluginNodeSelector` | Zusätzliche Node-Auswahl für Pods	Entspricht dem Format `pod.spec.nodeSelector`. | Kein Standard; optional 


| `controllerPluginTolerations` | Überschreibt Kubernetes-Toleranzen für Pods. Entspricht dem gleichen Format wie `pod.spec.Tolerations`. | Kein Standard; optional 


| `nodePluginNodeSelector` | Zusätzliche Node-Auswahl für Pods Entspricht dem Format `pod.spec.nodeSelector`. | Kein Standard; optional 


| `nodePluginTolerations` | Überschreibt Kubernetes-Toleranzen für Pods. Entspricht dem gleichen Format wie `pod.spec.Tolerations`. | Kein Standard; optional 


| `nodePrep`  a| 
Ermöglicht Trident, die Nodes des Kubernetes-Clusters so vorzubereiten, dass Volumes mithilfe des angegebenen Daten-Storage-Protokolls gemanagt werden. *Derzeit `iscsi` wird nur der Wert unterstützt.*


NOTE: Ab OpenShift 4.19 ist die für diese Funktion unterstützte Mindestversion von Trident 25.06.1.
|  


| `k8sAPIQPS`  a| 
Das vom Controller bei der Kommunikation mit dem Kubernetes-API-Server verwendete Limit für Abfragen pro Sekunde (QPS).  Der Burst-Wert wird automatisch basierend auf dem QPS-Wert festgelegt.
| `100`; optional 


| `enableConcurrency`  a| 
Ermöglicht gleichzeitige Trident -Controller-Operationen für verbesserten Durchsatz.


NOTE: *Technische Vorschau*: Diese Funktion ist experimentell und unterstützt derzeit eingeschränkte parallele Arbeitsabläufe mit den Treibern ONTAP-NAS (nur NFS) und ONTAP-SAN (NVMe für Unified ONTAP 9) sowie die bestehende technische Vorschau für den Treiber ONTAP-SAN (iSCSI- und FCP-Protokolle in Unified ONTAP 9).
| Falsch 
|===

NOTE: Weitere Informationen zum Formatieren von Pod-Parametern finden Sie unter link:https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/["Pods werden Nodes zugewiesen"^].

[WARNING]
====
* Ändern Sie NICHT die Namen von Containern oder Feldern.
* Ändern Sie die Einrückung NICHT – die YAML-Einrückung ist für die korrekte Analyse entscheidend.


====
[NOTE]
====
* Standardmäßig gelten keine Beschränkungen – nur Anfragen haben Standardwerte, die automatisch angewendet werden, sofern keine anderen Werte angegeben sind.
* Die Containernamen werden so aufgelistet, wie sie in den Pod-Spezifikationen erscheinen.
* Die Beiwagen sind unter jedem Hauptcontainer aufgeführt.
* Überprüfen Sie die TORCs `status.CurrentInstallationParams` Feld zur Anzeige der aktuell angewendeten Werte.


====
a|

[source, yaml]
----
resources:
  controller:
    trident-main:
      requests:
        cpu: 10m
        memory: 80Mi
      limits:
          cpu:
          memory:
    csi-provisioner:
      requests:
        cpu: 2m
        memory: 20Mi
      limits:
        cpu:
        memory:
    csi-attacher:
      requests:
        cpu: 2m
        memory: 20Mi
      limits:
        cpu:
        memory:
    csi-resizer:
      requests:
        cpu: 3m
        memory: 20Mi
      limits:
        cpu:
        memory:
    csi-snapshotter:
      requests:
        cpu: 2m
        memory: 20Mi
      limits:
        cpu:
        memory:
    trident-autosupport:
      requests:
        cpu: 1m
        memory: 30Mi
      limits:
        cpu:
        memory:
  node:
    linux:
      trident-main:
        requests:
          cpu: 10m
          memory: 60Mi
        limits:
          cpu:
          memory:
      node-driver-registrar:
        requests:
          cpu: 1m
          memory: 10Mi
        limits:
          cpu:
          memory:
    windows:
      trident-main:
        requests:
          cpu: 6m
          memory: 40Mi
        limits:
          cpu:
          memory:
      node-driver-registrar:
        requests:
          cpu: 6m
          memory: 40Mi
        limits:
          cpu:
          memory:
      liveness-probe:
        requests:
          cpu: 2m
          memory: 40Mi
        limits:
          cpu:
          memory:
----
|`httpsMetrics`|Aktivieren Sie HTTPS für den Prometheus-Metrikendpunkt.  |falsch|`hostNetwork` a|Aktiviert die Host-Netzwerkverbindung für den Trident -Controller.  Dies ist nützlich, wenn Sie den Frontend- und Backend-Datenverkehr in einem Netzwerk mit mehreren Heimnetzwerken trennen möchten.  |falsch

|===


| [HINWEIS] Weitere Informationen zur Formatierung von Pod-Parametern finden Sie unterlink:https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/["Pods werden Nodes zugewiesen"^] Die  == Beispielkonfigurationen Sie können die Attribute in<<Konfigurationsoptionen>> bei der Definition `TridentOrchestrator` um Ihre Installation individuell anzupassen.  .Grundlegende benutzerdefinierte Konfiguration [%collapsible%closed] ==== Dieses Beispiel wurde nach dem Ausführen von `cat deploy/crds/tridentorchestrator_cr_imagepullsecrets.yaml` Befehl, stellt eine einfache benutzerdefinierte Installation dar: [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident imagePullSecrets: - thisisasecret ---- ==== .Node selectors [%collapsible%closed] ==== Dieses Beispiel installiert Trident mit Node-Selektoren.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident controllerPluginNodeSelector: nodetype: master nodePluginNodeSelector: storage: netapp ---- ==== .Windows worker nodes [%collapsible%closed] ==== Dieses Beispiel wurde nach dem Ausführen des `cat deploy/crds/tridentorchestrator_cr.yaml` Befehl, installiert Trident auf einem Windows-Worker-Knoten.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident windows: true ---- ==== .Verwaltete Identitäten auf einem AKS-Cluster [%collapsible%closed] ==== Dieses Beispiel installiert Trident , um verwaltete Identitäten auf einem AKS-Cluster zu aktivieren.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident cloudProvider: "Azure" ---- ==== .Cloud-Identität auf einem AKS-Cluster [%collapsible%closed] ==== Dieses Beispiel installiert Trident zur Verwendung mit einer Cloud-Identität auf einem AKS-Cluster.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident cloudProvider: "Azure" cloudIdentity: 'azure.workload.identity/client-id: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx' ---- ==== .Cloud-Identität auf einem EKS-Cluster [%collapsible%closed] ==== Dieses Beispiel installiert Trident zur Verwendung mit einer Cloud-Identität auf einem AKS-Cluster.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident cloudProvider: "AWS" cloudIdentity: "'eks.amazonaws.com/role-arn: arn:aws:iam::123456:role/trident-role'" ---- ==== .Cloud-Identität für GKE [%collapsible%closed] ==== Dieses Beispiel installiert Trident zur Verwendung mit einer Cloud-Identität auf einem GKE-Cluster.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentBackendConfig metadata: name: backend-tbc-gcp-gcnv spec: version: 1 storageDriverName: google-cloud-netapp-volumes projectNumber: '012345678901' network: gcnv-network location: us-west2 serviceLevel: Premium storagePool: pool-premium1 ---- ==== .Kubernetes-Ressourcenanforderungen und -limits-Konfiguration für Trident -Controller und Trident -Linux-Node-Pods [%collapsible%closed] ==== Dieses Beispiel konfiguriert Kubernetes-Ressourcenanforderungen und -limits für Trident -Controller und Trident -Linux-Node-Pods.  WARNUNG: *Haftungsausschluss*: Die in diesem Beispiel angegebenen Anforderungs- und Grenzwerte dienen nur zu Demonstrationszwecken.  Passen Sie diese Werte an Ihre Umgebung und Ihre Arbeitslastanforderungen an.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident imagePullSecrets: - thisisasecret resources: controller: trident-main: requests: cpu: 10m memory: 80Mi limits: cpu: 200m memory: 256Mi # sidecars csi-provisioner: requests: cpu: 2m memory: 20Mi limits: cpu: 100m memory: 64Mi csi-attacher: requests: cpu: 2m memory: 20Mi limits: cpu: 100m memory: 64Mi csi-resizer: requests: cpu: 3m memory: 20Mi limits: cpu: 100m memory: 64Mi csi-snapshotter: requests: cpu: 2m memory: 20Mi limits: cpu: 100m Speicher: 64 Mi trident-autosupport: Anforderungen: CPU: 1 m Speicher: 30 Mi Limits: CPU: 50 m Speicher: 128 Mi Knoten: Linux: trident-main: Anforderungen: CPU: 10 m Speicher: 60 Mi Limits: CPU: 200 m Speicher: 256 Mi # Sidecars node-driver-registrar: Anforderungen: CPU: 1 m Speicher: 10 Mi Limits: CPU: 50 m Speicher: 32 Mi ---- ==== .Kubernetes-Ressourcenanforderungen und -limits-Konfiguration für Trident -Controller und Trident Windows- und Linux-Knoten-Pods [%collapsible%closed] ==== Dieses Beispiel konfiguriert Kubernetes-Ressourcenanforderungen und -limits für Trident -Controller und Trident Windows- und Linux-Knoten-Pods.  WARNUNG: *Haftungsausschluss*: Die in diesem Beispiel angegebenen Anforderungs- und Grenzwerte dienen nur zu Demonstrationszwecken.  Passen Sie diese Werte an Ihre Umgebung und Ihre Arbeitslastanforderungen an.  [source,yaml] ---- apiVersion: trident.netapp.io/v1 kind: TridentOrchestrator metadata: name: trident spec: debug: true namespace: trident imagePullSecrets: - thisisasecret windows: true resources: controller: trident-main: requests: cpu: 10m memory: 80Mi limits: cpu: 200m Speicher: 256 Mi # Sidecars csi-provisioner: Anforderungen: CPU: 2m Speicher: 20 Mi Limits: CPU: 100m Speicher: 64 Mi csi-attacher: Anforderungen: CPU: 2m Speicher: 20 Mi Limits: CPU: 100m Speicher: 64 Mi csi-resizer: Anforderungen: CPU: 3m Speicher: 20 Mi Limits: CPU: 100m Speicher: 64 Mi csi-snapshotter: Anforderungen: CPU: 2m Speicher: 20 Mi Limits: CPU: 100m Speicher: 64 Mi trident-autosupport: Anforderungen: CPU: 1m Speicher: 30 Mi Limits: CPU: 50m Speicher: 128 Mi node: linux: trident-main: Anforderungen: CPU: 10m Speicher: 60 Mi Limits: CPU: 200m Speicher: 256 Mi # Sidecars node-driver-registrar: Anforderungen: CPU: 1m Speicher: 10Mi Grenzen: CPU: 50m Speicher: 32Mi windows: trident-main: Anforderungen: CPU: 6m Speicher: 40Mi Grenzen: CPU: 200m Speicher: 128Mi # Sidecars node-driver-registrar: Anforderungen: CPU: 6m Speicher: 40Mi Grenzen: CPU: 100m Speicher: 128Mi liveness-probe: Anforderungen: CPU: 2m Speicher: 40Mi Grenzen: CPU: 50m Speicher: 64Mi ---- ==== 
|===